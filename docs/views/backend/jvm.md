---
title: JVM 和 GC
date: 2020-01-12
tags:
  - jvm
  - Java
categories:
  - "后端"
isShowComments: false
---

<Boxx/>

[[toc]]

## JVM

- JVM 是运行在操作系统之上的，它与硬件没有直接的交互

![](/tangsanshao7/img/backend/jvm/jvm001.png)

### 类装载器

1. 启动类加载器（Bootstrap）C++编写：Java 程序入口，加载 Java 基础包
2. 扩展类加载器（Extension）Java 编写：加载 javax 包
3. 应用类加载器（AppClassLoader）Java 编写：加载我们自己写的类
4. 用户自定义加载器：对自带的三种加载器不满足的话，继承 ClassLoader，自定义一个我们自己需求的类加载器

![](/tangsanshao7/img/backend/jvm/jvm002.png)

#### ClassLoader 的双亲委派机制

- 比如我们自己也写了一个名为 Java.Lang.String 的类，但启动会报错，因为 Java 类加载是从顶部的启动类加载器：Bootstrap 开始加载的

> 当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成。
>
> 每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到 BootStrap 中，只有当父类加载器反馈无法完成这个请求的时候（在它的加载路径下没有找到所需的 Class 文件），子类加载器才会尝试自己去加载。

- 正因为这样，所以 Java 是沙箱安全的：防止我们自己写的代码污染 Java 源代码

### Execution Engine 执行引擎

- 相当于解释执行器：负责将.Class 二进制代码文件翻译为操作系统能读懂的机器码，提交操作系统执行

### Native Interface 本地接口

- 本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为 native 的代码，它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载 native libraies。
- 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的架构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。

### 永久代（元空间）

- 永久存储区是一个常驻内存区域，用于存放 JDK 自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。

### 栈 stack

- 先进后出，负责 Java 程序的运行，随着线程的创建而开始，随着线程的消亡而结束
- 在程序从第一个方法（main）开始运行时，每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
- 栈帧中主要保存 3 类数据：
  1. 本地变量（Local Variables）：输入参数和输出参数以及方法内的变量
  2. 栈操作（Operand Stack）：记录出栈、入栈的操作
  3. 栈帧数据（Frame Data）：包括类文件、方法等等

![](/tangsanshao7/img/backend/jvm/jvm003.png)

### 堆 heap

![](/tangsanshao7/img/backend/jvm/jvm004.png)

1. 新生代
   - 伊甸区：占新生代的 8/10 （98%的 GC 回收都在这）
   - from 区： 占新生代的 1/10 （ GC 杀完伊甸区没杀干净的 ）
   - to 区： 占新生代的 1/10 （ GC 杀伊甸区和 from 区没杀干净的 ）
2. 老年代
   - GC 回收完新生代后残余的（新生代活过 15 次的）占堆内存的 2/3
   - GC 回收一般只在新生代，只有 Full GC 的时候才会回收老年代
3. 元空间
   - 跟堆内存没有关系

- 堆调优

  | 参数               | 含义                                    |
  | ------------------ | --------------------------------------- |
  | -Xms               | 设置初始分配大小，默认为物理内存的 1/64 |
  | -Xmx               | 最大分配内存，默认为物理内存的 1/4      |
  | -XX:PrintGCDetails | 输出详细的 GC 处理日志                  |

  一般 jvm 调优指的就是堆调优

### jvm 调优

- 如何调优：一般初始内存-Xms 和最大内存-Xmx 调成一样大小，避免 GC 和应用程序争抢内存，导致内存值忽高忽低

- 配置：在 IDEA 中 -> 菜单栏 Run -> Eidt Configurations -> VM optioins 中输入调优参数

- OOM: java.lang.OutOfMemory：

> 比方说配置的堆内存是 4M，但是我们 new 了一个 5M 的数组，就会报堆内存溢出异常

> 如果出现 java.lang.OutOfMemoryError: Java heap space 异常，说明 Java 虚拟机的堆内存不够。原因有二：
> （1）Java 虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx 来调整。
> （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。

## GC

![](/tangsanshao7/img/backend/jvm/gc001.png)

### MinorGC 的过程（复制->清空->互换）

1. eden、SurvivorFrom 复制到 SurvivorTo，年龄+1
   首先，当 Eden 区满的时候会触发第一次 GC,把还活着的对象拷贝到 SurvivorFrom 区，当 Eden 区再次触发 GC 的时候会扫描 Eden 区和 From 区域,对这两个区域进行垃圾回收，经过这次回收后还存活的对象,则直接复制到 To 区域（如果有对象的年龄已经达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1
2. 清空 eden、SurvivorFrom
   然后，清空 Eden 和 SurvivorFrom 中的对象，也即复制之后有交换，谁空谁是 to
3. SurvivorTo 和 SurvivorFrom 互换
   最后，SurvivorTo 和 SurvivorFrom 互换，原 SurvivorTo 成为下一次 GC 时的 SurvivorFrom 区。部分对象会在 From 和 To 区域中复制来复制去,如此交换 15 次(由 JVM 参数 MaxTenuringThreshold 决定,这个参数默认是 15),最终如果还是存活,就存入到老年代

### GC 算法

1. 引用计数法

   what：记录的是一个对象被引用的次数（有几个箭头指向我这个地址），如果有人用我就+1，没人用我就-1，到 0 的时候就被回收

   缺点：1）每次对象赋值的时候都要维护计数器，且计数器本身也有一定的消耗。2）较难处理循环引用

   谁用了：微软的 COM，python

2. 复制算法

   > **年轻代**中使用的 Minor GC，这种 GC 算法用的就是复制算法

   ![](/tangsanshao7/img/backend/jvm/gc002.png)

   缺点： 消耗空间（每次都从 from 区复制到 to 区，也正是 from 区和 to 区所占空间为 1:1 的原因）

   ​ （对象存活率非常低才适合用）

   优点：不会产生内存碎片，效率高

3. 标记清除法

   > **老年代**一般是由标记清除或者是标记清除与标记整理的混合实现

   ![](/tangsanshao7/img/backend/jvm/gc003.png)

   ![](/tangsanshao7/img/backend/jvm/gc004.png)

   what：算法分为“标记”和“清除”两个阶段，首先标记出所需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

   缺点：1）效率问题：标记和清除的效率都不高(遍历)。2）空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致大对象无法分配到足够的连续内存，从而不得不提前触发 GC，甚至程序中断。

4. 标记整理法

   ![](/tangsanshao7/img/backend/jvm/gc005.png)

   在标记清除后，再对存活对象内存和可用内存进行一遍有序整理（相当于解决内存碎片问题），相当于标记清除的升级版，但效率肯定更慢一点。

5. 分代收集算法

   次数上频繁收集 young 区，次数上较少收集 old 区，基本不动元空间

## Minor GC 和 Full GC

> 都发生在堆中

- Minor GC：是新生代 GC，指的是发生在新生代的垃圾收集动作。由于 Java 对象大都是朝生夕死，所以 Minor GC 的发生非常频繁，一般回收速度也比较快。

- Full GC/Major GC：是老年代的 GC，出现 Major GC 一般都伴有 Minor GC，Major GC 肯定比 Minor GC 慢很多。

- 何时发生？

  Minor GC：当 jvm 无法为新对象分配空间的时候就会发生 Minor GC，所以 new 对象的频率越高，越容易触发。

  Full GC：① 当老年代空间不足的时候会触发 Full GC，Full GC 会同时将老年代和新生代的垃圾进行回收。 ② 当发生 Minor GC 的时候可能触发 Full GC，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不知道自己要担保多少空间，因此老年代采用动态估值的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次 Minor GC 之后，存活的对象剧增（假设），但此时老年代并没有满，但是此时平均值增加了，就会发生 Full GC。

## 栈溢出和堆溢出

- 栈溢出：栈溢出是指不断的调用方法，不断的压栈，最终超出了栈允许的栈深度，就会发生栈溢出，比如递归操作没有终止，死循环。
- 栈内存溢出：对于一台服务器而言，每一个用户请求，都会产生一个线程来处理这个请求，每一个线程对应着一个栈，栈会分配内存，此时如果请求过多，这时候内存不够了，就会发生栈内存溢出。

- 堆溢出：不断的 new 一个对象，一直创建新的对象， 或者直接创建的对象太大了超过了堆内存（夸张的说）。
